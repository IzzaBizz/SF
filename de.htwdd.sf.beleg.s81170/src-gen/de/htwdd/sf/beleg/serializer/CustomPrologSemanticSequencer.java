/*
 * generated by Xtext 2.12.0
 */
package de.htwdd.sf.beleg.serializer;

import com.google.inject.Inject;
import de.htwdd.sf.beleg.customProlog.Atom;
import de.htwdd.sf.beleg.customProlog.Clause;
import de.htwdd.sf.beleg.customProlog.CustomPrologPackage;
import de.htwdd.sf.beleg.customProlog.Exquery;
import de.htwdd.sf.beleg.customProlog.Fact;
import de.htwdd.sf.beleg.customProlog.Folge;
import de.htwdd.sf.beleg.customProlog.Functor;
import de.htwdd.sf.beleg.customProlog.List;
import de.htwdd.sf.beleg.customProlog.Model;
import de.htwdd.sf.beleg.customProlog.NonEmptyList;
import de.htwdd.sf.beleg.customProlog.Predicate;
import de.htwdd.sf.beleg.customProlog.Program;
import de.htwdd.sf.beleg.customProlog.Prologdsl;
import de.htwdd.sf.beleg.customProlog.Query;
import de.htwdd.sf.beleg.customProlog.Rule;
import de.htwdd.sf.beleg.customProlog.Term;
import de.htwdd.sf.beleg.services.CustomPrologGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CustomPrologSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CustomPrologGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CustomPrologPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CustomPrologPackage.ATOM:
				sequence_Atom(context, (Atom) semanticObject); 
				return; 
			case CustomPrologPackage.CLAUSE:
				sequence_Clause(context, (Clause) semanticObject); 
				return; 
			case CustomPrologPackage.EXQUERY:
				sequence_Exquery(context, (Exquery) semanticObject); 
				return; 
			case CustomPrologPackage.FACT:
				sequence_Fact(context, (Fact) semanticObject); 
				return; 
			case CustomPrologPackage.FOLGE:
				sequence_Folge(context, (Folge) semanticObject); 
				return; 
			case CustomPrologPackage.FUNCTOR:
				sequence_Functor(context, (Functor) semanticObject); 
				return; 
			case CustomPrologPackage.LIST:
				sequence_List(context, (List) semanticObject); 
				return; 
			case CustomPrologPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case CustomPrologPackage.NON_EMPTY_LIST:
				sequence_NonEmptyList(context, (NonEmptyList) semanticObject); 
				return; 
			case CustomPrologPackage.PREDICATE:
				sequence_Predicate(context, (Predicate) semanticObject); 
				return; 
			case CustomPrologPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case CustomPrologPackage.PROLOGDSL:
				sequence_Prologdsl(context, (Prologdsl) semanticObject); 
				return; 
			case CustomPrologPackage.QUERY:
				sequence_Query(context, (Query) semanticObject); 
				return; 
			case CustomPrologPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case CustomPrologPackage.TERM:
				sequence_Term(context, (Term) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Atom returns Atom
	 *
	 * Constraint:
	 *     (ident=IDENT | ident=NUMBER | ident=VARIABLE)
	 */
	protected void sequence_Atom(ISerializationContext context, Atom semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Clause
	 *
	 * Constraint:
	 *     (fact=Fact | rule=Rule)
	 */
	protected void sequence_Clause(ISerializationContext context, Clause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Exquery returns Exquery
	 *
	 * Constraint:
	 *     query=Query
	 */
	protected void sequence_Exquery(ISerializationContext context, Exquery semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CustomPrologPackage.Literals.EXQUERY__QUERY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CustomPrologPackage.Literals.EXQUERY__QUERY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExqueryAccess().getQueryQueryParserRuleCall_1_0(), semanticObject.getQuery());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Fact returns Fact
	 *
	 * Constraint:
	 *     predicate=Predicate
	 */
	protected void sequence_Fact(ISerializationContext context, Fact semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CustomPrologPackage.Literals.FACT__PREDICATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CustomPrologPackage.Literals.FACT__PREDICATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFactAccess().getPredicatePredicateParserRuleCall_0_0(), semanticObject.getPredicate());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Folge returns Folge
	 *
	 * Constraint:
	 *     (atom+=Atom atom+=Atom*)
	 */
	protected void sequence_Folge(ISerializationContext context, Folge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Functor returns Functor
	 *
	 * Constraint:
	 *     funcName=IDENT
	 */
	protected void sequence_Functor(ISerializationContext context, Functor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CustomPrologPackage.Literals.FUNCTOR__FUNC_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CustomPrologPackage.Literals.FUNCTOR__FUNC_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctorAccess().getFuncNameIDENTTerminalRuleCall_0(), semanticObject.getFuncName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     List returns List
	 *
	 * Constraint:
	 *     nonempty=NonEmptyList?
	 */
	protected void sequence_List(ISerializationContext context, List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     expressions+=Prologdsl+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NonEmptyList returns NonEmptyList
	 *
	 * Constraint:
	 *     (folge=Folge | (atom=Atom term=Term))
	 */
	protected void sequence_NonEmptyList(ISerializationContext context, NonEmptyList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Predicate returns Predicate
	 *
	 * Constraint:
	 *     (functor=Functor term+=Term term+=Term*)
	 */
	protected void sequence_Predicate(ISerializationContext context, Predicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     clauses+=Clause+
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Prologdsl returns Prologdsl
	 *
	 * Constraint:
	 *     (program=Program exquery=Exquery)
	 */
	protected void sequence_Prologdsl(ISerializationContext context, Prologdsl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CustomPrologPackage.Literals.PROLOGDSL__PROGRAM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CustomPrologPackage.Literals.PROLOGDSL__PROGRAM));
			if (transientValues.isValueTransient(semanticObject, CustomPrologPackage.Literals.PROLOGDSL__EXQUERY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CustomPrologPackage.Literals.PROLOGDSL__EXQUERY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrologdslAccess().getProgramProgramParserRuleCall_0_0(), semanticObject.getProgram());
		feeder.accept(grammarAccess.getPrologdslAccess().getExqueryExqueryParserRuleCall_1_0(), semanticObject.getExquery());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Query returns Query
	 *
	 * Constraint:
	 *     (p+=Predicate p+=Predicate*)
	 */
	protected void sequence_Query(ISerializationContext context, Query semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     (rule=Predicate query=Query)
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CustomPrologPackage.Literals.RULE__RULE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CustomPrologPackage.Literals.RULE__RULE));
			if (transientValues.isValueTransient(semanticObject, CustomPrologPackage.Literals.RULE__QUERY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CustomPrologPackage.Literals.RULE__QUERY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRuleAccess().getRulePredicateParserRuleCall_0_0(), semanticObject.getRule());
		feeder.accept(grammarAccess.getRuleAccess().getQueryQueryParserRuleCall_2_0(), semanticObject.getQuery());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns Term
	 *
	 * Constraint:
	 *     (atom=Atom | list=List)
	 */
	protected void sequence_Term(ISerializationContext context, Term semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
