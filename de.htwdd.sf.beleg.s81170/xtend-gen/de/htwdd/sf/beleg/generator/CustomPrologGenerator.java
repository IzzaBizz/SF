/**
 * generated by Xtext 2.11.0
 */
package de.htwdd.sf.beleg.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import de.htwdd.sf.beleg.customProlog.Atom;
import de.htwdd.sf.beleg.customProlog.Clause;
import de.htwdd.sf.beleg.customProlog.Exquery;
import de.htwdd.sf.beleg.customProlog.Fact;
import de.htwdd.sf.beleg.customProlog.Folge;
import de.htwdd.sf.beleg.customProlog.List;
import de.htwdd.sf.beleg.customProlog.NonEmptyList;
import de.htwdd.sf.beleg.customProlog.Predicate;
import de.htwdd.sf.beleg.customProlog.Prologdsl;
import de.htwdd.sf.beleg.customProlog.Query;
import de.htwdd.sf.beleg.customProlog.Rule;
import de.htwdd.sf.beleg.customProlog.Term;
import java.util.LinkedList;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class CustomPrologGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    String text = "";
    Iterable<Prologdsl> _filter = Iterables.<Prologdsl>filter(IteratorExtensions.<EObject>toIterable(resource.getAllContents()), Prologdsl.class);
    for (final Prologdsl e : _filter) {
      String _text = text;
      String _transpile = this.transpile(e);
      String _plus = (_transpile + " ");
      text = (_text + _plus);
    }
    String _text_1 = text;
    text = (_text_1 + "\n]");
    InputOutput.<String>println(text);
    fsa.generateFile("prolog_s81170.lsp", text);
  }
  
  public String transpileList(final List l) {
    String ret = "";
    if ((l == null)) {
      String _ret = ret;
      ret = (_ret + ")");
      return ret;
    }
    NonEmptyList _nonempty = l.getNonempty();
    boolean _tripleNotEquals = (_nonempty != null);
    if (_tripleNotEquals) {
      String _ret_1 = ret;
      ret = (_ret_1 + "");
      String _ret_2 = ret;
      String _transpileNonEmptyList = this.transpileNonEmptyList(l.getNonempty());
      ret = (_ret_2 + _transpileNonEmptyList);
      String _ret_3 = ret;
      ret = (_ret_3 + ")");
    } else {
      String _ret_4 = ret;
      ret = (_ret_4 + "()");
    }
    String _ret_5 = ret;
    ret = (_ret_5 + "");
    return ret;
  }
  
  public String transpileNonEmptyList(final NonEmptyList list) {
    String ret = "(cons ";
    Atom _atom = list.getAtom();
    boolean _tripleNotEquals = (_atom != null);
    if (_tripleNotEquals) {
      String _ret = ret;
      String _ident = list.getAtom().getIdent();
      String _plus = (" " + _ident);
      ret = (_ret + _plus);
    } else {
      Folge _folge = list.getFolge();
      boolean _tripleNotEquals_1 = (_folge != null);
      if (_tripleNotEquals_1) {
        LinkedList<Atom> stack = new LinkedList<Atom>();
        int counter = 0;
        boolean _equals = Objects.equal(ret, "(cons ");
        if (_equals) {
          ret = "";
        }
        stack.addAll(list.getFolge().getAtom());
        while ((stack.isEmpty() != true)) {
          {
            counter++;
            String _ret_1 = ret;
            String _ident_1 = stack.pop().getIdent();
            String _plus_1 = ("(cons " + _ident_1);
            String _plus_2 = (_plus_1 + " ");
            ret = (_ret_1 + _plus_2);
            int _size = stack.size();
            boolean _equals_1 = (_size == 0);
            if (_equals_1) {
              String _ret_2 = ret;
              ret = (_ret_2 + "()");
            }
          }
        }
        for (int i = 0; (i < (counter - 1)); i++) {
          String _ret_1 = ret;
          ret = (_ret_1 + ")");
        }
      }
    }
    Term _term = list.getTerm();
    boolean _tripleNotEquals_2 = (_term != null);
    if (_tripleNotEquals_2) {
      String _ret_1 = ret;
      String _ident_1 = list.getTerm().getAtom().getIdent();
      String _plus_1 = (" " + _ident_1);
      String _plus_2 = (_plus_1 + " ");
      ret = (_ret_1 + _plus_2);
    }
    Term _term_1 = null;
    if (list!=null) {
      _term_1=list.getTerm();
    }
    List _list = null;
    if (_term_1!=null) {
      _list=_term_1.getList();
    }
    boolean _tripleNotEquals_3 = (_list != null);
    if (_tripleNotEquals_3) {
      String _ret_2 = ret;
      Object _transpileList = this.transpileList(list.getTerm().getList());
      ret = (_ret_2 + _transpileList);
    }
    return ret;
  }
  
  public String transpileTerm(final Term term) {
    String ret = " ";
    Atom _atom = term.getAtom();
    boolean _tripleNotEquals = (_atom != null);
    if (_tripleNotEquals) {
      String _ret = ret;
      String _ident = term.getAtom().getIdent();
      String _plus = (_ident + " ");
      ret = (_ret + _plus);
    } else {
      List _list = term.getList();
      boolean _tripleNotEquals_1 = (_list != null);
      if (_tripleNotEquals_1) {
        String _ret_1 = ret;
        String _transpileList = this.transpileList(term.getList());
        ret = (_ret_1 + _transpileList);
      }
    }
    return ret;
  }
  
  public String transpileClauses(final EList<Clause> clauses) {
    String ret = "";
    String _ret = ret;
    ret = (_ret + "");
    for (final Clause c : clauses) {
      {
        Fact _fact = c.getFact();
        boolean _tripleEquals = (_fact == null);
        if (_tripleEquals) {
          String _ret_1 = ret;
          String _transpileRule = this.transpileRule(c.getRule());
          ret = (_ret_1 + _transpileRule);
        }
        boolean _and = false;
        Fact _fact_1 = c.getFact();
        Predicate _predicate = null;
        if (_fact_1!=null) {
          _predicate=_fact_1.getPredicate();
        }
        boolean _tripleNotEquals = (_predicate != null);
        if (!_tripleNotEquals) {
          _and = false;
        } else {
          Fact _fact_2 = c.getFact();
          boolean _tripleNotEquals_1 = (_fact_2 != null);
          _and = _tripleNotEquals_1;
        }
        if (_and) {
          String _ret_2 = ret;
          String _transpilePredicates = this.transpilePredicates(c.getFact().getPredicate());
          String _plus = ("(" + _transpilePredicates);
          String _plus_1 = (_plus + ")\n");
          ret = (_ret_2 + _plus_1);
        }
      }
    }
    String _ret_1 = ret;
    ret = (_ret_1 + ")");
    return ret;
  }
  
  public String transpileRule(final Rule rule) {
    String ret = "(";
    String _ret = ret;
    String _transpilePredicates = this.transpilePredicates(rule.getRule());
    ret = (_ret + _transpilePredicates);
    String _ret_1 = ret;
    String _transpileQuery = this.transpileQuery(rule.getQuery());
    ret = (_ret_1 + _transpileQuery);
    String _ret_2 = ret;
    ret = (_ret_2 + ")");
    return ret;
  }
  
  public String transpilePredicates(final Predicate predicate) {
    String ret = "";
    if (((predicate != null) && (predicate.getFunctor().getFuncName() != null))) {
      String _ret = ret;
      String _funcName = predicate.getFunctor().getFuncName();
      String _plus = ("(" + _funcName);
      ret = (_ret + _plus);
      EList<Term> _term = null;
      if (predicate!=null) {
        _term=predicate.getTerm();
      }
      for (final Term t : _term) {
        String _ret_1 = ret;
        String _transpileTerm = this.transpileTerm(t);
        ret = (_ret_1 + _transpileTerm);
      }
      String _ret_2 = ret;
      ret = (_ret_2 + ")");
    }
    return ret;
  }
  
  public String transpileQuery(final Query q) {
    String ret = "";
    if ((q != null)) {
      ret = "";
      EList<Predicate> _p = q.getP();
      for (final Predicate p : _p) {
        if ((p != null)) {
          String _ret = ret;
          String _transpilePredicates = this.transpilePredicates(p);
          ret = (_ret + _transpilePredicates);
        }
      }
      String _ret_1 = ret;
      ret = (_ret_1 + "");
    }
    return ret;
  }
  
  public String transpile(final Prologdsl p) {
    String ret = "(prolog (quote ";
    String _ret = ret;
    ret = (_ret + "(");
    String _ret_1 = ret;
    String _transpileClauses = this.transpileClauses(p.getProgram().getClauses());
    ret = (_ret_1 + _transpileClauses);
    String _ret_2 = ret;
    ret = (_ret_2 + ")");
    String _ret_3 = ret;
    ret = (_ret_3 + "\n");
    String _ret_4 = ret;
    Exquery _exquery = null;
    if (p!=null) {
      _exquery=p.getExquery();
    }
    String _transpileQuery = this.transpileQuery(_exquery.getQuery());
    String _plus = ("(quote (" + _transpileQuery);
    ret = (_ret_4 + _plus);
    Exquery _exquery_1 = p.getExquery();
    boolean _tripleNotEquals = (_exquery_1 != null);
    if (_tripleNotEquals) {
      String _ret_5 = ret;
      ret = (_ret_5 + ")");
    }
    String _ret_6 = ret;
    ret = (_ret_6 + "))");
    return ret;
  }
}
